# Multi-File C Integration Example

This example demonstrates how to use ZLang's multi-file compilation with C library integration. It shows how to call external C functions through wrapper functions in a multi-file ZLang project.

## Project Structure

- `main.zl` - Main ZLang file that calls the square function
- `wrapper.zl` - Wrapper file containing C function declaration and ZLang wrapper function
- `cfunc.c` - Simple C source file with the `square` function implementation
- `cfunc` - Compiled C object file (generated by build script)
- `build.sh` - Build script to compile the entire project

## Files Description

### main.zl
```
use wrapper;

fun main() >> i32 {
    @printf("5 ^ 2 = %d", square(5));
    return 0;
}
```

### wrapper.zl
```zl
fun @square(n: i32) >> i32;  // External C function declaration

fun square(n: i32) >> i32 {  // ZLang wrapper function
    return @square(n);       // Calls the external C function
}
```

### cfunc.c
```c
int square(int n) {
    return n * n;
}
```

## Building and Running

### Using the Build Script (Recommended)

The `build.sh` script provides the easiest way to build this project. It automatically detects the zlang compiler and handles all build steps:

1. Make sure you have built the ZLang compiler (`zig build`)
2. Run the build script:
   ```bash
   ./build.sh
   ```

#### Build Script Configuration

The script has several variables you can modify:

```bash
CCOMPILER_PATH="gcc"                     # C compiler (gcc, clang, etc.)
OUTPUT_NAME="multi_file_c_example"       # Output executable name
SOURCE_FILES="main.zl wrapper.zl"        # ZLang source files
LINK_OBJECTS="cfunc"                     # C object files to link
KEEP_LL=false                           # Set to true to keep LLVM IR files
```

#### Advanced Usage

Keep LLVM IR files for debugging:
```bash
KEEP_LL=true ./build.sh
```

### Manual Build

If you prefer to build manually:

1. Compile the C object file:
   ```bash
   gcc -c cfunc.c -o cfunc
   ```

2. Compile the ZLang project:
   ```bash
   ../../../zig-out/bin/zlang main.zl wrapper.zl -o multi_file_c_example -link cfunc
   ```

3. Run the executable:
   ```bash
   ./multi_file_c_example
   ```

## Expected Output

When you run the executable, you should see:
```
5 ^ 2 = 25
```

## Configuration

The `build.sh` script has several configuration variables at the top that you can modify:

- `ZLANG_PATH`: Path to the zlang compiler
- `CCOMPILER_PATH`: Path to the C compiler (gcc, clang, etc.)
- `OUTPUT_NAME`: Name of the output executable
- `SOURCE_FILES`: List of ZLang source files
- `LINK_OBJECTS`: List of C object files to link
- `KEEP_LL`: Set to `true` to keep LLVM IR files for debugging

## What This Example Demonstrates

1. **Multi-file compilation**: How to split ZLang code across multiple files
2. **C integration**: How to call external C functions using `@` syntax
3. **Wrapper functions**: Best practice of wrapping external C functions in ZLang functions
4. **Import system**: Using `use` statements to import functions from other files
5. **Linking**: How to link compiled C object files with ZLang code

## Technical Details

This example fixes a previous issue where wrapper functions would call themselves recursively instead of the external C function. The ZLang compiler now correctly prioritizes external function declarations over defined functions when resolving function calls.

The LLVM IR shows:
- Main function calls `@square` (external declaration)
- Wrapper function `square.1` calls `@square` (external declaration)
- Proper external declaration: `declare i32 @square(i32)`

This ensures no infinite recursion occurs and the program runs successfully.